#  Cap√≠tulo 2: Indexaci√≥n
## Objetivos de los Laboratorios
-	Construir √≠ndices B-Tree avanzados (multicolumna, parciales y sobre expresiones) y evaluar su impacto real.
-	Diagnosticar cu√°ndo un √≠ndice ayuda y cu√°ndo no, usando EXPLAIN ANALYZE, estad√≠sticas y par√°metros de autovacuum.
-	Profundizar en m√©tricas cr√≠ticas (Heap Fetches, Rows Removed by Filter, Loops, Buffercache Hits).
-	Aplicar buenas pr√°cticas de dise√±o de √≠ndices y demostrar problemas comunes (selectividad baja, funciones en columnas, inserciones masivas).
________________________________________
## Laboratorio 2.1 ‚Äì Creaci√≥n y Diagn√≥stico de √çndices B-Tree
### Paso 1. Preparaci√≥n de datos
```sql
CREATE TABLE clientes (
    id SERIAL PRIMARY KEY,
    nombre TEXT,
    apellido TEXT,
    activo BOOLEAN,
    fecha_registro DATE DEFAULT now()
);
```
-- Insertamos 1 mill√≥n de registros con distribuci√≥n controlada
```sql
INSERT INTO clientes (nombre, apellido, activo)
SELECT 
    md5(random()::text), 
    (ARRAY['Garc√≠a','L√≥pez','Hern√°ndez','Mart√≠nez','Ram√≠rez'])[floor(random()*5)+1],
    (random() < 0.7) -- 70% activos
FROM generate_series(1, 1000000);
```
üëâ Con esto tendremos una tabla grande, con apellidos poco selectivos y un booleano (activo) de baja selectividad.
________________________________________
### Paso 2. √çndice est√°ndar
```sql
CREATE INDEX idx_clientes_apellido ON clientes (apellido);
Consulta de prueba:
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM clientes WHERE apellido = 'Garc√≠a';
```
üëâ Observa:
-	Index Scan o Bitmap Index Scan.
-	Heap Fetches: ¬øcu√°ntas veces tuvo que ir a la tabla tras usar el √≠ndice?

### Paso 3. √çndice multicolumna
```sql
CREATE INDEX idx_clientes_apellido_nombre ON clientes (apellido, nombre);
Consulta de prueba:
EXPLAIN (ANALYZE, BUFFERS)
SELECT * 
FROM clientes 
WHERE apellido = 'Garc√≠a' AND nombre LIKE 'a%';
```
üëâ Compara con el √≠ndice simple.

Pregunta de an√°lisis: ¬øqu√© mejora y qu√© sigue igual?

### Paso 4. √çndice parcial
```sql
CREATE INDEX idx_clientes_activos ON clientes (apellido)
WHERE activo = true;
Consulta de prueba:
EXPLAIN (ANALYZE, BUFFERS)
SELECT * 
FROM clientes 
WHERE apellido = 'Garc√≠a' AND activo = true;
```
üëâ Analiza:
-	Diferencia en Rows Removed by Filter.
-	Menor n√∫mero de p√°ginas le√≠das vs √≠ndice normal.

### Paso 5. √çndice sobre expresi√≥n
```sql
CREATE INDEX idx_clientes_apellido_lower ON clientes (LOWER(apellido));
```
Comparaci√≥n:
-- Sin √≠ndice de expresi√≥n
```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM clientes WHERE LOWER(apellido) = 'garc√≠a';
```
-- Con √≠ndice de expresi√≥n
```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM clientes WHERE LOWER(apellido) = 'garc√≠a';
```
üëâ Verifica c√≥mo cambia de Seq Scan ‚Üí Index Scan.

## Laboratorio 2.2 ‚Äì Casos donde los B-Tree NO ayudan
### Paso 1. Baja selectividad
```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM clientes WHERE activo = true;
```
üëâ Aunque hay un √≠ndice, PostgreSQL har√° un Seq Scan porque casi toda la tabla cumple la condici√≥n.

### Paso 2. Agregaci√≥n masiva
```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT COUNT(*) FROM clientes;
```
üëâ Ning√∫n √≠ndice ayuda: se necesita un Seq Scan.

### Paso 3. Inserciones masivas y page splits
-- √çndice con fillfactor para optimizar inserciones
```sql
CREATE INDEX idx_clientes_fecha_registro
ON clientes (fecha_registro) WITH (fillfactor = 70);
```
-- Simulaci√≥n de inserciones diarias
```sql
INSERT INTO clientes (nombre, apellido, activo, fecha_registro)
SELECT md5(random()::text), 'Nuevo', true, now()
FROM generate_series(1,100000);
```
üëâ Usa pg_stat_all_indexes para observar crecimiento y validaci√≥n de page splits.

## Laboratorio 2.3 ‚Äì Interpretaci√≥n avanzada con EXPLAIN
### Paso 1. M√©tricas cr√≠ticas
Ejecuta una consulta con BUFFERS y analiza:
```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM clientes WHERE apellido = 'Ram√≠rez';
```
üëâ Interpreta:
-	Heap Fetches: ¬øel √≠ndice est√° accediendo demasiado a la tabla? ‚Üí considerar √≠ndices covering.
-	Rows Removed by Filter: ¬øel √≠ndice devuelve demasiados falsos positivos? ‚Üí usar parcial.
-	Buffers: cache hits vs lecturas desde disco.

### Paso 2. √çndices covering (INCLUDE)
```sql
CREATE INDEX idx_clientes_apellido_include ON clientes (apellido) INCLUDE (nombre);
Consulta:
EXPLAIN (ANALYZE, BUFFERS)
SELECT apellido, nombre FROM clientes WHERE apellido = 'L√≥pez';
```
üëâ Observa c√≥mo ya no necesita Heap Fetches.

## Tarea Final del Cap√≠tulo
1.	Dise√±ar un set de consultas frecuentes (ej. b√∫squedas por apellido, b√∫squedas por clientes activos, b√∫squedas case-insensitive).
2.	Crear diferentes tipos de √≠ndices (est√°ndar, multicolumna, parcial, expresi√≥n, covering).
3.	Medir el impacto con EXPLAIN (ANALYZE, BUFFERS) y documentar:
-	Costos estimados vs reales.
-	Accesos al heap.
-	P√°ginas le√≠das desde disco.
-	Diferencia en tiempo de ejecuci√≥n.

üìã Gu√≠a de Interpretaci√≥n de EXPLAIN (Checklist Experto)
Cuando ejecutes:

```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT ...;
```
Tendr√°s salida con estimaciones y resultados reales. Interpr√©tala as√≠:

 ### 1. Tipo de operaci√≥n
-	Seq Scan ‚Üí PostgreSQL lee toda la tabla.
‚ûù √ötil si no hay √≠ndices o la selectividad es muy baja.
-	Index Scan ‚Üí usa el √≠ndice y va al heap por cada fila.
‚ûù Puede generar muchos Heap Fetches.
-	Bitmap Index Scan ‚Üí el √≠ndice devuelve posiciones de p√°ginas, se agrupan y luego se leen en bloque.
‚ûù Eficiente para condiciones que devuelven muchas filas.
‚úîÔ∏è Pregunta: ¬øel plan us√≥ √≠ndice cuando esperabas?

 ### 2. Costos estimados
Cada operaci√≥n tiene:
(cost=0.29..8.30 rows=5 width=64)
-	0.29 ‚Üí costo de inicio (primer fila).
-	8.30 ‚Üí costo total estimado.
-	rows=5 ‚Üí filas estimadas.
-	width=64 ‚Üí tama√±o medio de cada fila (bytes).
‚úîÔ∏è Pregunta: ¬øla estimaci√≥n de filas (rows) se acerca a la realidad? Si no, revisar estad√≠sticas con ANALYZE.

 ### 3. Resultados reales

Ejemplo:
(actual time=0.020..0.025 rows=5 loops=1)
-	actual time=... ‚Üí tiempo real (inicio..fin).
-	rows=5 ‚Üí filas reales devueltas.
-	loops=1 ‚Üí n√∫mero de veces que se ejecut√≥ este plan.
‚úîÔ∏è Pregunta: ¬ølas filas reales coinciden con las estimadas? Si no, el optimizador puede elegir mal los planes.

 ### 4. M√©tricas cr√≠ticas
-	Index Cond ‚Üí condici√≥n usada en el √≠ndice.
‚ûù Si est√° vac√≠a o solo ves Filter, el √≠ndice no se aprovech√≥.
-	Filter ‚Üí condici√≥n aplicada despu√©s de leer datos.
‚ûù Si aqu√≠ se eliminan muchas filas (Rows Removed by Filter), quiz√° necesites un √≠ndice parcial.
-	Heap Fetches ‚Üí accesos a la tabla despu√©s de usar el √≠ndice.
‚ûù Demasiados fetches ‚Üí eval√∫a √≠ndices covering con INCLUDE.
‚úîÔ∏è Pregunta: ¬øest√°s filtrando demasiado tarde? ¬øse puede optimizar con √≠ndices parciales o covering?

 ### 5. Estad√≠sticas de memoria y cache (BUFFERS)

Con (BUFFERS) aparecen:
-	shared hit ‚Üí p√°ginas le√≠das desde cache (r√°pido).
-	shared read ‚Üí p√°ginas le√≠das desde disco (lento).
-	shared dirtied ‚Üí p√°ginas modificadas.
-	shared written ‚Üí p√°ginas escritas.
‚úîÔ∏è Pregunta: ¬øhay demasiados read? ‚Üí mejorar √≠ndices, aumentar cache (shared_buffers) o reescribir la consulta.

 ### 6. Escalabilidad y bucles
-	Si loops es alto ‚Üí la operaci√≥n se repite muchas veces.
‚ûù Com√∫n en Nested Loop. Puede explotar con millones de filas.
-	Si ves Hash Join o Merge Join, revisa si los √≠ndices permiten un Index Nested Loop m√°s eficiente.
‚úîÔ∏è Pregunta: ¬øel plan es escalable para millones de filas o solo funciona en pruebas peque√±as?

 ### 7. Diagn√≥stico final
-	¬øEl plan us√≥ el √≠ndice correcto?
-	¬øLas estimaciones de filas fueron realistas?
-	¬øSe generaron demasiados Heap Fetches o Rows Removed by Filter?
-	¬øEl acceso a disco (read) es alto comparado con hit?
-	¬øEl plan elegido escala con m√°s datos?

## Ejemplo R√°pido Adicional
```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM clientes WHERE LOWER(apellido) = 'garc√≠a';
```
Salida (simplificada):
```
Seq Scan on clientes  (cost=0.00..35000.00 rows=500 width=64)
(actual time=0.05..120.00 rows=500 loops=1)
  Filter: (lower(apellido) = 'garc√≠a')
  Rows Removed by Filter: 999500
  Buffers: shared hit=100, read=2000
```
‚úÖ Diagn√≥stico con checklist:
```
1.	Seq Scan ‚Üí No us√≥ √≠ndice.
2.	Rows Removed by Filter = 999500 ‚Üí p√©sima eficiencia.
3.	read=2000 ‚Üí demasiadas lecturas desde disco.
```
üëâ Soluci√≥n: crear un √≠ndice de expresi√≥n LOWER(apellido).

Con esta gu√≠a, puedes leer un plan de ejecuci√≥n, detectando cuellos de botella y justificando decisiones de indexaci√≥n.

##  Tarea Final ‚Äì Cap√≠tulo 2: Indexaci√≥n (Nivel Avanzado)
 
## Objetivo
Dise√±ar, crear y evaluar estrategias de indexaci√≥n avanzadas sobre una tabla de clientes simulada. El alumno deber√° justificar con evidencia (EXPLAIN ANALYZE, BUFFERS) por qu√© un √≠ndice mejora (o no) el rendimiento.

### Preparaci√≥n de datos
```sql
CREATE TABLE clientes (
    id SERIAL PRIMARY KEY,
    nombre TEXT,
    apellido TEXT,
    activo BOOLEAN,
    fecha_registro DATE DEFAULT now()
);
```
-- Insertar 1 mill√≥n de registros de prueba
```sql
INSERT INTO clientes (nombre, apellido, activo, fecha_registro)
SELECT 
    md5(random()::text),
    (ARRAY['Garc√≠a','L√≥pez','Hern√°ndez','Mart√≠nez','Ram√≠rez'])[floor(random()*5)+1],
    (random() < 0.7), -- 70% activos
    now() - (random() * 365)::int * interval '1 day'
FROM generate_series(1,1000000);
```

### Parte 1. Consultas frecuentes
```
Los alumnos deben ejecutar estas consultas representativas:
1.	B√∫squeda exacta por apellido
2.	SELECT * FROM clientes WHERE apellido = 'Garc√≠a';
3.	B√∫squeda combinada (apellido + nombre inicial)
4.	SELECT * FROM clientes 
5.	WHERE apellido = 'Mart√≠nez' AND nombre LIKE 'a%';
6.	B√∫squeda solo de clientes activos
7.	SELECT * FROM clientes WHERE activo = true;
8.	B√∫squeda case-insensitive
9.	SELECT * FROM clientes WHERE LOWER(apellido) = 'l√≥pez';
10.	Consulta de reporte parcial (solo columnas espec√≠ficas)
11.	SELECT apellido, nombre FROM clientes WHERE apellido = 'Ram√≠rez';
```

### Parte 2. Creaci√≥n de √≠ndices avanzados
```
El alumno deber√° crear y evaluar los siguientes √≠ndices:
1.	√çndice est√°ndar
2.	CREATE INDEX idx_apellido ON clientes (apellido);
3.	√çndice multicolumna
4.	CREATE INDEX idx_apellido_nombre ON clientes (apellido, nombre);
5.	√çndice parcial
6.	CREATE INDEX idx_activos ON clientes (apellido)
7.	WHERE activo = true;
8.	√çndice sobre expresi√≥n
9.	CREATE INDEX idx_apellido_lower ON clientes (LOWER(apellido));
10.	√çndice covering
11.	CREATE INDEX idx_apellido_include ON clientes (apellido) INCLUDE (nombre);
```

### Parte 3. Medici√≥n del impacto

Ejecutar cada consulta con y sin √≠ndice, usando:
```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT ...
```
Y documentar en una tabla comparativa como la siguiente:

![Tabla de resultados](TablaIndices.png)
Consulta	√çndice aplicado	Costo estimado	Filas estimadas vs reales	Heap Fetches	Buffers (hit vs read)	Tiempo ejecuci√≥n (ms)	Observaciones
Buscar apellido exacto	idx_apellido	0.29..8.30	500 vs 498	500	hit=50, read=5	0.05	Buen match, planificador acert√≥
Case-insensitive	idx_apellido_lower	0.29..12.00	200 vs 195	200	hit=40, read=3	0.04	El √≠ndice evita el Seq Scan
Clientes activos	idx_activos	0.30..500	700000 vs 690000	Alto	read elevado	85.0	Muy baja selectividad, no conviene √≠ndice

### Parte 4. Informe final
El alumno deber√° entregar un informe escrito que incluya:
-	Capturas de EXPLAIN (ANALYZE, BUFFERS).
-	Comparaci√≥n de cada √≠ndice en t√©rminos de:
    - Diferencia entre costos estimados y reales.
    - Reducci√≥n (o no) de Heap Fetches.
    - Impacto en lecturas desde disco vs cache.
    - Variaci√≥n en tiempo de ejecuci√≥n.
-	Conclusiones sobre:
    - Qu√© √≠ndices son m√°s √∫tiles en este dataset?
    - ¬øQu√© √≠ndices son in√∫tiles o incluso perjudiciales?
    - ¬øC√≥mo cambia la estrategia de indexaci√≥n si los datos crecen a 10M registros?

üìå Con esta tarea final, hemos practicado el dise√±o, diagn√≥stico y justificaci√≥n del uso de √≠ndices, logrando pensar como un DBA de PostgreSQL en producci√≥n.

# Cap√≠tulo 3: Manejo de Transacciones

---

**[‚¨ÖÔ∏è Atr√°s](https://netec-mx.github.io/POSTSQL_ADV/Cap%C3%ADtulo2/)** | **[Lista general üóÇÔ∏è](https://netec-mx.github.io/POSTSQL_ADV/)** | **[Siguiente ‚û°Ô∏è](https://netec-mx.github.io/POSTSQL_ADV/Cap%C3%ADtulo4/)**

---

## Laboratorio 3.1 ‚Äì Uso b√°sico de transacciones

### Objetivo  
Comprender el funcionamiento b√°sico de las transacciones en PostgreSQL mediante el uso de `BEGIN`, `COMMIT` y `ROLLBACK`.

### Requisitos  
- PostgreSQL instalado y funcionando.  
- Tabla de prueba creada con datos.

### Pasos

1. Acceder a `psql` y seleccionar la base de datos:
   ```bash
   psql -U usuario -d basededatos
   ```
2.	Crear una tabla simple para pruebas:
    ```sql
    CREATE TABLE cuentas (
    id SERIAL PRIMARY KEY,
    titular VARCHAR(100),
    saldo NUMERIC
    );

    INSERT INTO cuentas (titular, saldo) VALUES ('Juan', 1000), ('Ana', 1500);
    ```
3.	Iniciar una transacci√≥n y actualizar saldo:
    ```sql
    BEGIN;
    UPDATE cuentas SET saldo = saldo - 100 WHERE titular = 'Juan';
    UPDATE cuentas SET saldo = saldo + 100 WHERE titular = 'Ana';
    ```
    -- No hacer COMMIT todav√≠a
4.	Consultar los saldos dentro de la misma sesi√≥n:
    ```sql
    SELECT * FROM cuentas;
    ```
5.	Abrir otra sesi√≥n psql y consultar la tabla:
    ```sql
    SELECT * FROM cuentas;
    ```
    Nota: Ver√°s que los cambios a√∫n no son visibles aqu√≠.
6.	Volver a la primera sesi√≥n y realizar un ROLLBACK para deshacer cambios:
    ```sql
    ROLLBACK;
    ```
7.	Consultar nuevamente los saldos para confirmar reversi√≥n.
8.	Repetir la transacci√≥n, pero ahora realizar un COMMIT para confirmar cambios:
    ```sql
    BEGIN;
    UPDATE cuentas SET saldo = saldo - 100 WHERE titular = 'Juan';
    UPDATE cuentas SET saldo = saldo + 100 WHERE titular = 'Ana';
    COMMIT;
    ```
9.	Verificar que los cambios ahora son visibles en ambas sesiones.

### Explicaci√≥n
Este laboratorio muestra c√≥mo las transacciones agrupan operaciones para que se ejecuten todas o ninguna, garantizando atomicidad y consistencia.

## Laboratorio 3.2 ‚Äì Bloqueos pesimistas
### Objetivo
Simular bloqueos pesimistas en PostgreSQL para entender c√≥mo se gestionan conflictos entre sesiones concurrentes.
### Requisitos
‚Ä¢	PostgreSQL en ejecuci√≥n.
‚Ä¢	Tabla con datos para prueba (por ejemplo, la tabla cuentas del laboratorio 3.1).
### Pasos
1.	Abrir dos sesiones psql conectadas a la misma base.
2.	En la sesi√≥n 1, iniciar transacci√≥n y bloquear una fila:
    ```sql
    BEGIN;
    SELECT * FROM cuentas WHERE titular = 'Juan' FOR UPDATE;
    ```
    -- No hacer COMMIT ni ROLLBACK todav√≠a
3.	En la sesi√≥n 2, intentar actualizar la misma fila:
- Esta operaci√≥n quedar√° bloqueada esperando a que la sesi√≥n 1 termine.
4.	Volver a sesi√≥n 1 y finalizar la transacci√≥n con:
    ```sql
    COMMIT;
    ```
5.	La sesi√≥n 2 continuar√° y podr√° completar la actualizaci√≥n.
6.	Observar y analizar el comportamiento.
### Explicaci√≥n
El bloqueo FOR UPDATE impide que otras transacciones modifiquen la fila hasta que se libere el bloqueo, previniendo inconsistencias.

## Laboratorio 3.3 ‚Äì Observaci√≥n de MVCC (Multi-Version Concurrency Control)
### Objetivo
Observar c√≥mo PostgreSQL maneja versiones m√∫ltiples de filas para permitir concurrencia sin bloqueos pesados.
### Requisitos
‚Ä¢	Tabla cuentas con datos.
‚Ä¢	Dos sesiones psql abiertas.
### Pasos
1.	En la sesi√≥n 1, ejecutar una consulta para obtener xmin y xmax (identificadores de versi√≥n):
    ```sql
    SELECT id, titular, saldo, xmin, xmax FROM cuentas;
    ```
2.	En la sesi√≥n 2, iniciar transacci√≥n y actualizar una fila:
    ```sql
    BEGIN;
    UPDATE cuentas SET saldo = saldo + 200 WHERE titular = 'Juan';
    ```
3.	En la sesi√≥n 1, volver a consultar la tabla con xmin y xmax.
4.	Observar que la fila tiene una versi√≥n nueva (nuevo xmin) mientras la antigua persiste visible para la sesi√≥n 1.
5.	En la sesi√≥n 2, hacer COMMIT.
6.	En la sesi√≥n 1, consultar nuevamente y notar el cambio en versiones.
#### Explicaci√≥n
MVCC permite que diferentes transacciones vean versiones distintas de una fila para evitar bloqueos, manteniendo consistencia.


## Laboratorio 3.4 ‚Äì An√°lisis de VACUUM y autovacuum
### Objetivo
Entender la funci√≥n de VACUUM y autovacuum para limpiar filas obsoletas y mantener el rendimiento.
### Requisitos
- PostgreSQL en ejecuci√≥n.
- Tabla con actividad (como cuentas).
### Pasos
1.	Realizar m√∫ltiples actualizaciones y eliminaciones en la tabla para generar filas muertas:
    ```sql
    UPDATE cuentas SET saldo = saldo + 50 WHERE titular = 'Ana';
    DELETE FROM cuentas WHERE titular = 'Carlos'; -- Si existe
    ```
2.	Ejecutar manualmente VACUUM:
    ```sql
    VACUUM VERBOSE cuentas;
    ```
3.	Observar el reporte detallado del proceso.
4.	Consultar par√°metros relacionados con autovacuum:
    ```sql
    SHOW autovacuum;
    SHOW autovacuum_vacuum_threshold;
    SHOW autovacuum_vacuum_scale_factor;
    ```
5.	Simular actividad intensa para forzar autovacuum (puede usar scripts o varias actualizaciones).
6.	Revisar logs para verificar ejecuci√≥n de autovacuum o usar vistas del sistema:
    ```sql
    SELECT * FROM pg_stat_activity WHERE query LIKE '%autovacuum%';
    ```
#### Explicaci√≥n
VACUUM limpia espacio ocupado por versiones antiguas de filas (tuplas muertas) para evitar crecimiento descontrolado de tablas y mantener performance. Autovacuum automatiza esta tarea.

---

**[‚¨ÖÔ∏è Atr√°s](https://netec-mx.github.io/POSTSQL_ADV/Cap%C3%ADtulo2/)** | **[Lista general üóÇÔ∏è](https://netec-mx.github.io/POSTSQL_ADV/)** | **[Siguiente ‚û°Ô∏è](https://netec-mx.github.io/POSTSQL_ADV/Cap%C3%ADtulo4/)**

---
